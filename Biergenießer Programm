#include <LiquidCrystal.h> 
#include <IRremote.h> 
 
int RECV_PIN = 31; 
IRrecv irrecv(RECV_PIN); 
decode_results results; 
LiquidCrystal lcd(30,36,42,44,45,43); 

//Feuchtigkeitssensor
#include "DHT.h" 
#include <DHT.h>
#define DHTPIN 2     // what digital pin we're connected to 
#define DHTTYPE DHT22   // DHT 22  (AM2302), AM2321 
 
// Connect pin 1 (on the left) of the sensor to +5V 
// NOTE: If using a board with 3.3V logic like an Arduino Due connect pin 1 
// to 3.3V instead of 5V! 
// Connect pin 2 of the sensor to whatever your DHTPIN is 
// Connect pin 4 (on the right) of the sensor to GROUND 
// Connect a 10K resistor from pin 2 (data) to pin 1 (power) of the sensor 
 
 
DHT dht(DHTPIN, DHTTYPE); 

//LED-Variablen
int GRUEN=7;
int GELB=5;
int ROT=6;

//Bibliothek für das SD-Kartenmodul
#include <SD.h>
File myFile;
int pinCS = 53; // Pin 10 on Arduino Uno
//PIN Belegung SD-Kartenmodul:
//MOSI=51
//MISO=50
//SCK=52
//CS=53

//Bibliothek für Die Uhr
//#include <DS3231.h> veraltet Bibliothek
#include <DS1307RTC.h>
#include <Time.h>
#include <TimeLib.h>
//DS3231  rtc(SDA, SCL) veraltet
//PIN Belegung DS3231 Modul:
//SDA= PIN 20
//SCL= PIN 21

int Minute;

bool LED_Gruen(float);              //Ausgelagerte Grenzen für die Ansteurung der LEDS
bool LED_Gelb(float);
bool LED_Rot(float);

 

int eingang= A7; //Das Wort „eingang“ steht jetzt für den Wert „A7“ (Bezeichnung vom Analogport 7)
int sensorWert = 0; //Variable für den Sensorwert mit 0 als Startwert
int Helligkeits_Bereich = 0;  //wird im späteren Verlauf für die ausgelagerte Funktion benutzt
int UV_Bereich = 0;           //wird im späteren Verlauf für die ausgelagerte Funktion benutzt
int UVWert = 85; //auf 85 gesetzt um zu zeigen, dass ein wert auf dem Display zu sehen ist


void setup()  
{ 
  Serial.begin(9600); 
  lcd.begin(16,2); 
  irrecv.enableIRIn();                                    //Reciever starten 

  dht.begin();                                            //Feuchtigkeitssensor starten

  pinMode(GRUEN,OUTPUT);                                  //Grüne LED  
  pinMode(GELB,OUTPUT);                                   //Gelbe LED
  pinMode(ROT,OUTPUT);                                    //Rote LED

  pinMode(pinCS, OUTPUT);                                 // SD-Karte Ausgang
   if (SD.begin())                                        // SD-Karte Statusmeldung
  {
    Serial.println("SD card is ready to use.");
  } else
  {
    Serial.println("SD card initialization failed");
    return;
  }

  setSyncProvider(RTC.get);
  setTime(12,59,00,25,06,2019);                           //Zeit einstellen

  /*rtc.begin();               //Zeit starten             //Zeit einstellungen veraltet
  rtc.setDOW(SATURDAY);     //Wochentag einstellen
  rtc.setTime(15, 15, 0);     //Uhrzeit einstellen
  rtc.setDate(21, 6, 2019);     //Datum einstellen
 */ 

 Minute=0;
 
} 
 
void loop()  
{ 
 while(results.value != 16761405)                         //Schleife, um Eingabe zu beginnen, bzw Aufforderung bis Eingabe getätigt wurde 
  { 
   lcd.setCursor(0,0); 
   lcd.print("Eingabe bitte");                            //Aufforderung zur Eingabe auf dem Display 
    
   if (irrecv.decode(&results))                           //Decodieren des IR-Signals zur Überprüfung 
    { 
      Serial.println(results.value, DEC);                 //Ausgabe des Wertes als DEC-Zahl auf dem seriellen Monitor 
      irrecv.resume();                                    //Den nächsten Wert emfangen 
    } 
       
   if(results.value == 16738455) 
    {  
       lcd.clear(); 
       lcd.setCursor(0,0);                                //Erste Zeile 
       lcd.print("Menueauswahl: "); 
       lcd.setCursor(0,1);                                //Zweite Zeile 
       lcd.print("1.Thore"); 
       delay (2000);                                      //2 Sekunden warten 
       lcd.clear();                                       //Display löschen 
 
       lcd.setCursor(0,0);          
       lcd.print("Menueauswahl: "); 
       lcd.setCursor(0,1);          
       lcd.print("2.Laura1"); 
       delay (2000);               
       lcd.clear();                 
 
       lcd.setCursor(0,0);          
       lcd.print("Menueauswahl: "); 
       lcd.setCursor(0,1);          
       lcd.print("3.Laura2"); 
       delay (2000);                
       lcd.clear(); 
 
       lcd.setCursor(0,0);          
       lcd.print("Menueauswahl: "); 
       lcd.setCursor(0,1);          
       lcd.print("4.Jonathan"); 
       delay (2000);                
       lcd.clear(); 
 
       lcd.setCursor(0,0);          
       lcd.print("Menueauswahl: "); 
       lcd.setCursor(0,1);          
       lcd.print("5.Lukas"); 
       delay (2000);                
       lcd.clear(); 
 
       lcd.setCursor(0,0);          
       lcd.print("Menueauswahl: "); 
       lcd.setCursor(0,1);          
       lcd.print("6.Dominik"); 
       delay (2000);                
       lcd.clear(); 
 
       lcd.setCursor(0,0);          
       lcd.print("Menueauswahl: "); 
       lcd.setCursor(0,1);          
       lcd.print("7.Thore2"); 
       delay (2000);                
       lcd.clear(); 
    } 
   
  if(results.value == 16724175)                           //Thores Quelltext, Programm Nr.1 
    {  
      lcd.clear();                                        //Eingabeaufforderung auf dem Display löschen 
       
        while(results.value != 16761405)                  //Schleife des Programms bis zu manuellen Beendigung mit der "Play"-Taste 
          { 
            lcd.setCursor(0,0); 
            lcd.print("Thores Pro");                      //Programmplatzhalter 
             
              if (irrecv.decode(&results))                //Eingabe zum Beenden am Ende des Programms 
                { 
                  Serial.println(results.value, DEC);     //Ausgabe des Wertes als DEC-Zahl auf dem seriellen Monitor 
                  irrecv.resume();                        //Den nächsten Wert emfangen 
                }   
          } 
    }  
  if(results.value==16718055)                             //Lauras Quelltext, Programm Nr.2 
    { 
      lcd.clear();                                        //Eingabeaufforderung auf dem Display löschen 
       
        while(results.value != 16761405)                  //Schleife des Programms bis zu manuellen Beendigung mit der "Play"-Taste 
          { 
            lcd.setCursor(0,0); 
            lcd.print("Prinzessin");                      //Programmplatzhalter 
             
              if (irrecv.decode(&results)) 
                { 
                  Serial.println(results.value, DEC);     //Ausgabe des Wertes als DEC-Zahl auf dem seriellen Monitor 
                  irrecv.resume();                        //Den nächsten Wert emfangen 
                } 
           } 
    } 
 
 
  if (results.value==16743045)                            //Laura2 Quelltext, Programm Nr.3 
    { 
      lcd.clear();                                        //Eingabeaufforderung auf dem Display löschen 
       
        while(results.value != 16761405)                  //Schleife des Programms bis zu manuellen Beendigung mit der "Play"-Taste 
          { 
            lcd.setCursor(0,0); 
            lcd.print("Prinzessin2");                        //Programmplatzhalter 
             
               if (irrecv.decode(&results))  
                 { 
                  Serial.println(results.value, DEC);     //Ausgabe des Wertes als DEC-Zahl auf dem seriellen Monitor 
                  irrecv.resume();                        //Den nächsten Wert emfangen 
                 } 
          } 
    } 
 
 
  if(results.value==16716015)                             //Jonathan Quelltext, Programm Nr.4 
    { 
      lcd.clear();                                        //Eingabeaufforderung auf dem Display löschen 
    
        while(results.value != 16761405)                  //Schleife des Programms bis zu manuellen Beendigung mit der "Play"-Taste 
          { 
              {


sensorWert =analogRead(eingang); //Die Spannung an dem Fotowiderstand auslesen und unter der Variable „sensorWert“ abspeichern.
    Serial.print("   Sensorwert = " ); //Ausgabe am Serial-Monitor: Das Wort „Sensorwert: „ Dient Lediglich der Überprüfung
    Serial.println(sensorWert); //Ausgabe am Serial-Monitor. Mit dem Befehl Serial.print wird der Sensorwert des Fotowiderstandes in Form einer Zahl zwischen 0 und 1023 an den serial monitor gesendet.

//ab hier: Verarbeitung der Sensorwerte für den Photowiderstand
// Unterteilung des Wertebereichs der Helligkeit in 5 Kategorien -> die Angaben von "--" bis "++" stehen hierbei für den erforderlichen Schutz, "--" Kein Schutz erforderlich, "++" Sehr hoher Schutz Erforderlich

//Funktionsaufruf der ausgelagerten Funktion
    Helligkeits_Bereich = fun_photoresistor(sensorWert); 

switch (Helligkeits_Bereich) //Nachdem die Funktion fun_photoresistor ausgeführt wurde werden im switch-case die 5 Kategorien unterscheiden und der jeweilige Schutz für die Augen wird auf dem Display ausgegeben
{
  case 1:
  {
    Serial.print("Augenschutz: -- ");    // zur Überprüfung, ausgabe auf dem PC
    // lcd.setCursor(0,0);                 //Eigendliche Ausgabe passiert hier -> auf LCD Display
    //lcd.print("Augenschutz: -- ");
    //delay (2000);
    //lcd.clear();
    break;
  }
  case 2:
  {
    Serial.print("Augenschutz: -  ");
    //lcd.setCursor(0,0);
    //lcd.print("Augenschutz: -  ");
    break;
  }
  case 3:
  {
    Serial.print("Augenschutz: o  ");
    //lcd.setCursor(0,0);
    //lcd.print("Augenschutz: o  ");
    break;
  }    
  case 4:
  {
    Serial.print("Augenschutz: +  ");
    //lcd.setCursor(0,0);
    //lcd.print("Augenschutz: +  ");
    break;
  }
  case 5:
  {
    Serial.print("Augenschutz: ++ ");
    //lcd.setCursor(0,0);
    //lcd.print("Augenschutz: ++ ");
    break;
  }
  default:
  {
    break; 
  }
}

//ab hier: Theoretische Sensorwerte für einen UV-Sensor einpflegen.
// -> die Sensorwerte des UV-Sensors würden von 0 bis 240 gehen, wobei <10 für einen UV-Index von 0 steht und >240 für einen von 11
//Um dem Nutzer über den aktuell notwendigen Sonnenschutz zu Informieren werden die UV-Indexe von 0-11 wieder in 5 Kategorien eingeteilt

UV_Bereich = fun_uv(UVWert); 

switch (UV_Bereich)
{
  case 1:
  {
    Serial.print("Hautschutz: --  ");      // ... soll diese Meldung im seriellen Monitor erscheinen. Bedeutung: Kein Hautschtuz erforderlich.
    //lcd.setCursor(0,1);                  //Eigendliche Ausgabe passiert hier -> auf LCD Display
    //lcd.print("Hautschutz: --  "); 
    break;
  }
  case 2:
  {
    Serial.print("Hautschutz: -   "); //Bedeutung: leichter Schutz erforderlich: z.B. Hut und leichte Sonnencreme.
    // lcd.setCursor(0,1);                 
    //lcd.print("Hautschutz: -   "); 
    break;
  }
  case 3:
  {
     Serial.print("Hautschutz: o   "); // Bedeutung: Schutz erforderlich : z.B. Hut, Sonnencreme & Schatten aufsuchen.
    //lcd.setCursor(0,1);                 
    //lcd.print("Hautschutz: o   "); 
    break;
  }
  case 4:
  {
     Serial.print("Hautschutz: +   "); //Bedeutung: Aufenthalt im Freien möglichst vermeiden. Wenn doch dann nur mit hohem Schutz.
    //lcd.setCursor(0,1);                 
    //lcd.print("Hautschutz: +   "); 
    break;
  }
  case 5:
  {
     Serial.print("Hautschutz: ++  "); //Bedeutung: Aufenthalt im Freien vermeiden. Falls doch nur mit Hut, starker Sonnencreme und nicht länger als 2 Stunden
    //lcd.setCursor(0,1);                 
    //lcd.print("Hautschutz: ++  "); 
    break;
  }
  default:
  {
    break; 
  }
}   //Schließt den switch case
      
             
              if (irrecv.decode(&results))  
                { 
                 Serial.println(results.value, DEC);      //Ausgabe des Wertes als DEC-Zahl auf dem seriellen Monitor 
                 irrecv.resume();                         //Den nächsten Wert emfangen 
                } 
          } 
    } 
 
  if(results.value==16726215)                             //Lukas Quelltext, Programm Nr.5 
    { 
      lcd.clear();                                        //Eingabeaufforderung auf dem Display löschen 
       
        while(results.value != 16761405)                  //Schleife des Programms bis zu manuellen Beendigung mit der "Play"-Taste 
          { 
          
          
          float h = dht.readHumidity();                   //Liest die Luftfeuchtigkeit aus und speichert sie in der Variable h ab  

          if(minute() == (Minute+10 %60)  )               // Zeitintervall zum Abspeichern in diesem Fall alle 10 Minuten    
          {
            Minute = minute();
            myFile = SD.open("Messwert.txt", FILE_WRITE);  //Abspeichern der Messwerte
            if (myFile) 
            {  
            myFile.print(rtc.getTimeStr());       //Zeitstempel
            myFile.print(",");       
            myFile.print("Luftfeuchtigkeit: ");
            myFile.print(h);
            myFile.println("%");
            myFile.close(); // close the file
            }
          }
          
             
          if (isnan(h))                                    // Checkt ob irgendwelche Fehler beim auslesen des Sensor gibt  und bricht das Programm früher ab
          { 
            Serial.println("Fehler beim auslesen des Sensors!"); 
            return; 
          } 

          lcd.setCursor(0, 0);                            //Startposition der Darstellung auf dem LCD festlegen. lcd.setCursor(0,0) bedeutet: Erstes Zeichen in der ersten Zeile. 
          lcd.print("Luftfeuchtigkeit:");  
          lcd.setCursor(0, 1);                            // lcd.setCursor(0,1) bedeutet: Erstes Zeichen in der zweiten Zeile. 
          lcd.print(h);
          lcd.print("%"); 
          
          Serial.print("Luftfeuchtigkeit: "); 
          Serial.print(h); 
          Serial.print(" %\t"); 

          if(LED_Gruen(h)==1)      
          {
            analogWrite(GRUEN,255);
          }
          if(LED_Gruen(h)==0)   
          {
            analogWrite(GRUEN,0);
          }

          if(LED_Gelb(h)==1)
          {
            analogWrite(GELB,255);
          }
          if(LED_Gelb(h)==0)
          {
            analogWrite(GELB,0);
          }

          if(LED_Rot(h)==1)
          {
            analogWrite(ROT,255);
            
          }
          if(LED_Rot(h)==0)
          {
            analogWrite(ROT,0);
          }

               
              if (irrecv.decode(&results))  
                { 
                 Serial.println(results.value, DEC);      //Ausgabe des Wertes als DEC-Zahl auf dem seriellen Monitor 
                 irrecv.resume();                         //Den nächsten Wert emfangen  
                } 
          } 
    } 
  if(results.value==16734885)                             //Dominik Quelltext, Programm Nr.6 
    { 
      lcd.clear();                                        //Eingabeaufforderung auf dem Display löschen 
       
        while(results.value != 16761405)                  //Schleife des Programms bis zu manuellen Beendigung mit der "Play"-Taste 
          { 
            lcd.setCursor(0,0); 
            lcd.print("Dominique");                       //Programmplatzhalter 
               
              if (irrecv.decode(&results))  
                { 
                 Serial.println(results.value, DEC);      //Ausgabe des Wertes als DEC-Zahl auf dem seriellen Monitor 
                 irrecv.resume();                         //Den nächsten Wert emfangen  
                } 
          } 
    } 
    if(results.value==16728765)                             //Thore2 Quelltext, Programm Nr.7 
    { 
      lcd.clear();                                        //Eingabeaufforderung auf dem Display löschen 
       
        while(results.value != 16761405)                  //Schleife des Programms bis zu manuellen Beendigung mit der "Play"-Taste 
          { 
            lcd.setCursor(0,0); 
            lcd.print("Thore2");                       //Programmplatzhalter 
               
              if (irrecv.decode(&results))  
                { 
                 Serial.println(results.value, DEC);      //Ausgabe des Wertes als DEC-Zahl auf dem seriellen Monitor 
                 irrecv.resume();                         //Den nächsten Wert emfangen  
                } 
          } 
    } 
  }  
 
    
 lcd.clear();                                             //Letzten Text vom gestarteten Programm auf dem Display löschen 
 lcd.setCursor(0,0); 
 lcd.print("Systemneustart");                             //Mitteilung an den Nutzer, dass gleich ein neues Programm gestartet werden kann 
 lcd.setCursor(0,1); 
 lcd.print("Bitte warten"); 
  
 delay(5000); 
 lcd.clear();                                             //Mitteilung vor Ende des Loops löschen 
  
 while(results.value == 16761405)                         //Schleife, um den Wert von "results" automatisch zu verändern 
  {                                                       //Sodass results.value nicht mehr den Wert der "Play"-Taste zugewiesen hat 
   if (irrecv.decode(&results)) 
    { 
     Serial.println(results.value, DEC);                  //Ausgabe des Wertes als DEC-Zahl auf dem seriellen Monitor 
     irrecv.resume();                                     //Den nächsten Wert emfangen 
    } 
  } 
  
}

//Ausgelagerte Funktionen für die Ansteurung der LED(Wertebereich)
bool LED_Gruen(float h)
{
  if(h>40 and h<60)
  {
    return 1;
  }
  else{return 0;}
  
}

bool LED_Gelb(float h)
{
  if(h>=60 and h<80)
  {
    return 1;
  }
  else{return 0;}
}

bool LED_Rot(float h)
{
  if(h>=80)
  {
    return 1;
  }
  else{return 0;}
}




int fun_photoresistor(int sensorWert) //Die Funktion unterteilt die Sensorwerte des Photowiderstandes (Eingabewert)in Kategorien von 1-5. Im Anschluss wird der Helligkeits_Bereich wieder zurück gegeben(Rückgabewert)
{
  if (sensorWert < 204 )//sehr dunkel
  {
    Helligkeits_Bereich=1;
    return Helligkeits_Bereich;
  }

  if (sensorWert >204 && sensorWert < 408)//etwas heller aber noch nahezu dunkel
  {
    Helligkeits_Bereich=2;
    return Helligkeits_Bereich;
  }
  
  if (sensorWert > 408 && sensorWert < 612)//hell, vergleichbar mit im Schatten vorm Tentomax sitzend
  {
    Helligkeits_Bereich=3;
    return Helligkeits_Bereich;
  }
  
  if (sensorWert > 612 && sensorWert < 816)//hell, direkte Sonneneinstrahlung
  {
    Helligkeits_Bereich=4;
    return Helligkeits_Bereich;
  }
  
  if (sensorWert > 816 )//sehr hell, direkte Sonneneinstrahlung
  {
    Helligkeits_Bereich=5;
    return Helligkeits_Bereich;
  }  
}

int fun_uv(int UVWert)
{
  //1. Katergorie: Index 0 bis 2
  if (UVWert < 65)      // Wenn der Sensorwert kleiner als 65 ist...
  {
    UV_Bereich=1;
    return UV_Bereich;
  }
  

  //2. Katergorie: Index 3 bis 5
  if (UVWert < 124 && UVWert > 65 )
  {
    UV_Bereich=2;
    return UV_Bereich;
  }
  

  //3. Katergorie: Index 6 bis 8
  if (UVWert < 180 && UVWert > 124 )
  {
    UV_Bereich=3;
    return UV_Bereich;
  }
  

  //4. Katergorie: Index 9 bis 10
  if (UVWert < 221 && UVWert > 180 )
  {
    UV_Bereich=4;
    return UV_Bereich;
  }
  
  //5. Katergorie: Index 11 und höher
  if (UVWert > 221 )
  {
    UV_Bereich=5;
    return UV_Bereich;
  }
}